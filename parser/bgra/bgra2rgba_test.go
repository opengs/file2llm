package bgra

import (
	"bytes"
	"testing"
)

func TestConvertBGRAtoRGBA_InPlace_AVX2(t *testing.T) {
	width, height := 4, 4
	stride := 4 * width
	data := []byte{
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
	}

	// Convert BGRA to RGBA in-place
	convertBGRAtoRGBAInplaceFunc(width, height, stride, data, bgraToRgbaInPlaceAVX2)

	// Expected output after in-place conversion
	expected := []byte{
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
	}

	// Check if the data is correctly modified
	if !bytes.Equal(data, expected) {
		t.Errorf("Expected %v, got %v", expected, data)
	}
}

func TestConvertBGRAtoRGBA_InPlace_SSE3(t *testing.T) {
	width, height := 8, 4
	stride := 4 * width
	data := []byte{
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
	}

	// Convert BGRA to RGBA in-place
	convertBGRAtoRGBAInplaceFunc(width, height, stride, data, bgraToRgbaInPlaceSSE3)

	// Expected output after in-place conversion
	expected := []byte{
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
	}

	// Check if the data is correctly modified
	if !bytes.Equal(data, expected) {
		t.Errorf("Expected %v, got %v", expected, data)
	}
}

func TestConvertBGRAtoRGBA_InPlace_fallback(t *testing.T) {
	width, height := 4, 4
	stride := 4 * width
	data := []byte{
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0xFF, 0xFF, 0x00, 0xFF,
	}
	for range 16 {

	}

	// Convert BGRA to RGBA in-place
	convertBGRAtoRGBAInplaceFunc(width, height, stride, data, bgraToRgbaInPlaceFallback)

	// Expected output after in-place conversion
	expected := []byte{
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
		0x00, 0x00, 0xFF, 0x00,
		0x00, 0xFF, 0x00, 0xFF,
		0xFF, 0x00, 0x00, 0x00,
		0x00, 0xFF, 0xFF, 0xFF,
	}

	// Check if the data is correctly modified
	if !bytes.Equal(data, expected) {
		t.Errorf("Expected %v, got %v", expected, data)
	}
}
